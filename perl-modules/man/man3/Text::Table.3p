.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Text::Table 3"
.TH Text::Table 3 2022-10-12 "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Text::Table \- Organize Data in Tables
.SH VERSION
.IX Header "VERSION"
version 1.135
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 11
\&    use Text::Table;
\&    my $tb = Text::Table\->new(
\&        "Planet", "Radius\enkm", "Density\eng/cm^3"
\&    );
\&    $tb\->load(
\&        [ "Mercury", 2360, 3.7 ],
\&        [ "Venus", 6110, 5.1 ],
\&        [ "Earth", 6378, 5.52 ],
\&        [ "Jupiter", 71030, 1.3 ],
\&    );
\&    print $tb;
.Ve
.PP
This prints a table from the given title and data like this:
.PP
.Vb 6
\&  Planet  Radius Density
\&          km     g/cm^3
\&  Mercury  2360  3.7
\&  Venus    6110  5.1
\&  Earth    6378  5.52
\&  Jupiter 71030  1.3
.Ve
.PP
Note that two-line titles work, and that the planet names are aligned
differently than the numbers.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Organization of data in table form is a time-honored and useful
method of data representation.  While columns of data are trivially
generated by computer through formatted output, even simple tasks
like keeping titles aligned with the data columns are not trivial,
and the one-shot solutions one comes up with tend to be particularly
hard to maintain.  Text::Table allows you to create and maintain
tables that adapt to alignment requirements as you use them.
.SS Overview
.IX Subsection "Overview"
The process is simple: you create a table (a Text::Table object) by
describing the columns the table is going to have.  Then you load
lines of data into the table, and finally print the resulting output
lines.  Alignment of data and column titles is handled dynamically
in dependence on the data present.
.SS "Table Creation"
.IX Subsection "Table Creation"
In the simplest case, if all you want is a number of (untitled) columns,
you create an unspecified table and start adding data to it.  The number
of columns is taken from the first line of data.
.PP
To specify a table you specify its columns.  A column description
can contain a title and alignment requirements for the data, both
optional.  Additionally, you can specify how the title is aligned with
the body of a column, and how the lines of a multiline title are
aligned among themselves.
.PP
The columns are collected in the table in the
order they are given.  On data entry, each column corresponds to
one data item, and in column selection columns are indexed left to
right, starting from 0.
.PP
Each title can be a multiline string which will be blank-filled to
the length of the longest partial line.  The largest number of title
lines in a column determines how many title lines the table has as a
whole, including the case that no column has any titles.
.PP
On output, columns are separated by a single blank.  You can control
what goes between columns by specifying separators between (or before,
or after) columns.  Separators don't contain any data and don't count
in column indexing.  They also don't accumulate: in a sequence of only
separators and no columns, only the last one counts.
.SS "Status Information"
.IX Subsection "Status Information"
The width (in characters), height (in lines), number of columns, and
similar data about the table is available.
.SS "Data Loading"
.IX Subsection "Data Loading"
Table data is entered line-wise, each time specifying data entries
for all table columns.  A bulk loader for many lines at once is also
available.  You can clear the data from the table for re-use (though
you will more likely just create another table).
.PP
Data can contain colorizing escape sequences (as provided by
\&\f(CW\*(C`Term::AnsiColor\*(C'\fR) without upsetting the alignment.
.SS "Table Output"
.IX Subsection "Table Output"
The output area of a table is divided in the title and the body.
.PP
The title contains the combined titles from the table columns, if
any.  Its content never changes with a given table, but it may be
spread out differently on the page through alignment with the data.
.PP
The body contains the data lines, aligned column-wise as specified,
and left-aligned with the column title.
.PP
Each of these is arranged like a Perl array (counting from 0) and can
be accessed in portions by specifying a first line and the number
of following lines.  Also like an array, giving a negative first line
counts from the end of the area.  The whole table, the title followed
by the body, can also be accessed in this manner.
.PP
The subdivisions are there so you can repeat the title (or parts of
it) along with parts of the body on output, whether for screen paging
or printout.
.PP
A rule line is also available, which is the horizontal counterpart to
the separator columns you specify with the table.
It is basically a table line as it would appear if all data entries
in the line were empty, that is, a blank line except for where the
column separators have non-blank entries.  If you print it between
data lines, it will not disrupt the vertical separator structure
as a plain blank line would.  You can also request a solid rule
consisting of any character, and even one with the non-blank column
separators replaced by a character of your choice.  This way you can
get the popular representation of line-crossings like so:
.PP
.Vb 3
\&      |
\&  \-\-\-\-+\-\-\-
\&      |
.Ve
.SS "Warning Control"
.IX Subsection "Warning Control"
On table creation, some parameters are checked and warnings issued
if you allow warnings.  You can also turn warnings into fatal errors.
.SH VERSION
.IX Header "VERSION"
version 1.135
.SH SPECIFICATIONS
.IX Header "SPECIFICATIONS"
.SS "Column Specification"
.IX Subsection "Column Specification"
Each column specification is a single scalar.  Columns can be either proper
data columns or column separators.  Both can be specified either as
(possibly multi-line) strings, or in a more explicit form as hash-refs.
In the string form, proper columns are given as plain strings, and
separators are given as scalar references to strings.  In hash form,
separators have a true value in the field \f(CW\*(C`is_sep\*(C'\fR while proper columns
don't have this field.
.IP "Columns as strings" 4
.IX Item "Columns as strings"
A column is given as a column title (any number of lines),
optionally followed by alignment requirements.  Alignment requirements
start with a line that begins with an ampersand "&".  However, only the
last such line counts as such, so if you have title lines that begin
with "&", just append an ampersand on a line by itself as a dummy
alignment section if you don't have one anyway.
.Sp
What follows the ampersand on its line is the alignment style (like
\&\fIleft\fR, \fIright\fR, ... as described in "Alignment"), you want for
the data in this column.  If nothing follows, the general default \fIauto\fR
is used.  If you specify an invalid alignment style, it falls back to
left alignment.
.Sp
The lines that follow can contain sample data for this column.  These
are considered for alignment in the column, but never actually appear
in the output.  The effect is to guarantee a minimum width for the
column even if the current data doesn't require it.  This helps dampen
the oscillations in the appearance of dynamically aligned tables.
.IP "Columns as Hashes" 4
.IX Item "Columns as Hashes"
The format is
.Sp
.Vb 7
\&    {
\&        title   => $title,
\&        align   => $align,
\&        sample  => $sample,
\&        align_title => $align_title,
\&        align_title_lines => $align_title_lines,
\&    }
.Ve
.Sp
\&\f(CW$title\fR contains the title lines and \f(CW$sample\fR the sample data.  Both can
be given as a string or as an array-ref to the list of lines.  \f(CW$align\fR contains
the alignment style (without a leading ampersand), usually as a string.
You can also give a regular expression here, which specifies regex alignment.
A regex can only be specified in the hash form of a column specification.
.Sp
In hash form you can also specify how the title of a column is aligned
with its body.  To do this, you specify the keyword \f(CW\*(C`align_title\*(C'\fR with
\&\f(CW\*(C`left\*(C'\fR, \f(CW\*(C`right\*(C'\fR or \f(CW\*(C`center\*(C'\fR.  Other alignment specifications are not
valid here.  The default is \f(CW\*(C`left\*(C'\fR.
.Sp
\&\f(CW\*(C`align_title\*(C'\fR also specifies how the lines of a multiline title are
aligned among themselves.  If you want a different alignment, you
can specify it with the key \f(CW\*(C`align_title_lines\*(C'\fR.  Again, only \f(CW\*(C`left\*(C'\fR,
\&\f(CW\*(C`right\*(C'\fR or \f(CW\*(C`center\*(C'\fR are allowed.
.Sp
Do not put other keys than those mentioned above (\fItitle\fR, \fIalign\fR,
\&\fIalign_title\fR, \fIalign_title_lines\fR, and \fIsample\fR) into a hash that
specifies a column.  Most would be ignored, but some would confuse the
interpreter (in particular, \fIis_sep\fR has to be avoided).
.IP "Separators as strings" 4
.IX Item "Separators as strings"
A separator must be given as a reference to a string (often a literal,
like \f(CW\*(C`\e\*(Aq | \*(Aq\*(C'\fR), any string that is given directly describes a column.
.Sp
It is usually just a (short) string that will be printed between
table columns on all table lines instead of the default single
blank.  If you specify two separators (on two lines), the first one
will be used in the title and the other in the body of the table.
.IP "Separators as Hashes" 4
.IX Item "Separators as Hashes"
The hash representation of a separator has the format
.Sp
.Vb 5
\&    {
\&        is_sep => 1,
\&        title  => $title,
\&        body   => $body,
\&    }
.Ve
.Sp
\&\f(CW$title\fR is the separator to be used in the title area and \f(CW$body\fR
the one for the body.  If only one is given, it will be used for
both.  If none is given, a blank is used.  If one is shorter than
the other, it is blank filled on the right.
.Sp
The value of \f(CW\*(C`is_sep\*(C'\fR must be set to a true value, this is the
distinguishing feature of a separator.
.SS Alignment
.IX Subsection "Alignment"
The original documentation to Text::Aligner contains all the details
on alignment specification, but here is the rundown:
.PP
The possible alignment specifications are \fIleft\fR, \fIright\fR, \fIcenter\fR,
\&\fInum\fR and \fIpoint\fR (which are synonyms), and \fIauto\fR.  The first
three explain themselves.
.PP
\&\fInum\fR (and \fIpoint\fR) align the decimal point in the data, which is
assumed to the right if none is present.  Strings that aren't
numbers are treated the same way, that is, they appear aligned
with the integers unless they contain a ".".  Instead of the
decimal point ".", you can also specify any other string in
the form \fInum(,)\fR, for instance.  The string in parentheses
is aligned in the data.  The synonym \fIpoint\fR for \fInum\fR may be
more appropriate in contexts that deal with arbitrary
strings, as in \fIpoint(=>)\fR (which might be used to align certain
bits of Perl code).
.PP
\&\fIregex alignment\fR is a more sophisticated form of point alignment.
If you specify a regular expression, as delivered by \f(CW\*(C`qr//\*(C'\fR, the start
of the match is used as the alignment point.  If the regex contains
capturing parentheses, the last submatch counts.  [The usefulness of
this feature is under consideration.]
.PP
\&\fIauto\fR alignment combines numeric alignment with left alignment.
Data items that look like numbers, and those that don't, form two
virtual columns and are aligned accordingly: \f(CW\*(C`num\*(C'\fR for numbers and
\&\f(CW\*(C`left\*(C'\fR for other strings.  These columns are left-aligned with
each other (i.e. the narrower one is blank-filled) to form the
final alignment.
.PP
This way, a column that happens to have only numbers in the data gets
\&\fInum\fR alignment, a column with no numbers appears \fIleft\fR\-aligned,
and mixed data is presented in a reasonable way.
.SS "Column Selection"
.IX Subsection "Column Selection"
Besides creating tables from scratch, they can be created by
selecting columns from an existing table.  Tables created this
way contain the data from the columns they were built from.
.PP
This is done by specifying the columns to select by their index
(where negative indices count backward from the last column).
The same column can be selected more than once and the sequence
of columns can be arbitrarily changed.  Separators don't travel
with columns, but can be specified between the columns at selection
time.
.PP
You can make the selection of one or more columns dependent on
the data content of one of them.  If you specify some of the columns
in angle brackets [...], the whole group is only included in the
selection if the first column in the group contains any data that
evaluates to boolean true.  That way you can de-select parts of a
table if it contains no interesting data.  Any column separators
given in brackets are selected or deselected along with the rest
of it.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.SS "Table Creation"
.IX Subsection "Table Creation"
.IP \fBnew()\fR 4
.IX Item "new()"
.Vb 1
\&    my $tb = Text::Table\->new( $column, ... );
.Ve
.Sp
creates a table with the columns specified.  A column can be proper column
which contains and displays data, or a separator which tells how to fill
the space between columns.  The format of the parameters is described under
"Column Specification". Specifying an invalid alignment for a column
results in a warning if these are allowed.
.Sp
If no columns are specified, the number of columns is taken from the first
line of data added to the table.  The effect is as if you had specified
\&\f(CW\*(C`Text::Table\->new( ( \*(Aq\*(Aq) x $n)\*(C'\fR, where \f(CW$n\fR is the number of
columns.
.IP \fBselect()\fR 4
.IX Item "select()"
.Vb 1
\&    my $sub = $tb\->select( $column, ...);
.Ve
.Sp
creates a table from the listed columns of the table \f(CW$tb\fR, including
the data.  Columns are specified as integer indices which refer to
the data columns of \f(CW$tb\fR.  Columns can be repeated and specified in any
order.  Negative indices count from the last column.  If an invalid
index is specified, a warning is issued, if allowed.
.Sp
As with "\fBnew()\fR", separators can be interspersed among the column
indices and will be used between the columns of the new table.
.Sp
If you enclose some of the arguments (column indices or separators) in
angle brackets \f(CW\*(C`[...]\*(C'\fR (technically, you specify them inside an
arrayref), they form a group for conditional selection.  The group is
only included in the resulting table if the first actual column inside
the group contains any data that evaluate to a boolean true.  This way
you can exclude groups of columns that wouldn't contribute anything
interesting.  Note that separators are selected and de-selected with
their group.  That way, more than one separator can appear between
adjacent columns.  They don't add up, but only the rightmost separator
is used.  A group that contains only separators is never selected.
[Another feature whose usefulness is under consideration.]
.SS "Status Information"
.IX Subsection "Status Information"
.IP \fBn_cols()\fR 4
.IX Item "n_cols()"
.Vb 1
\&    $tb\->n_cols
.Ve
.Sp
returns the number of columns in the table.
.IP \fBwidth()\fR 4
.IX Item "width()"
.Vb 1
\&    $tb\->width
.Ve
.Sp
returns the width (in characters) of the table.  All table lines have
this length (not counting a final "\en" in the line), as well as the
separator lines returned by \f(CW$tb\fR\->\fBrule()\fR and \f(CW$b\fR\->\fBbody_rule()\fR.
The width of a table can potentially be influenced by any data item
in it.
.IP \fBheight()\fR 4
.IX Item "height()"
.Vb 1
\&    $tb\->height
.Ve
.Sp
returns the total number of lines in a table, including title lines
and body lines. For orthogonality, the synonym \fBtable_height()\fR also
exists.
.IP \fBtable_height()\fR 4
.IX Item "table_height()"
Same as \f(CW\*(C`$table\->height()\*(C'\fR.
.IP \fBtitle_height()\fR 4
.IX Item "title_height()"
.Vb 1
\&    $tb\->title_height
.Ve
.Sp
returns the number of title lines in a table.
.IP \fBbody_height()\fR 4
.IX Item "body_height()"
.Vb 1
\&    $tb\->body_height
.Ve
.Sp
returns the number of lines in the table body.
.IP \fBcolrange()\fR 4
.IX Item "colrange()"
.Vb 1
\&    $tb\->colrange( $i)
.Ve
.Sp
returns the start position and width of the \f(CW$i\fR\-th column (counting from 0)
of the table.  If \f(CW$i\fR is negative, counts from the end of the table.  If \f(CW$i\fR
is larger than the greatest column index, an imaginary column of width 0
is assumed right of the table.
.SS "Data Loading"
.IX Subsection "Data Loading"
.IP \fBadd()\fR 4
.IX Item "add()"
.Vb 1
\&    $tb\->add( $col1, ..., $colN)
.Ve
.Sp
adds a data line to the table, returns the table.
.Sp
\&\f(CW$col1\fR, ..., \f(CW$colN\fR are scalars that
correspond to the table columns.  Undefined entries are converted to '',
and extra data beyond the number of table columns is ignored.
.Sp
Data entries can be multi-line strings.  The partial strings all go into
the same column.  The corresponding fields of other columns remain empty
unless there is another multi-line entry in that column that fills the
fields.  Adding a line with multi-line entries is equivalent to adding
multiple lines.
.Sp
Every call to \f(CWadd()\fR increases the body height of the table by the
number of effective lines, one in the absence of multiline entries.
.IP \fBload()\fR 4
.IX Item "load()"
.Vb 1
\&    $tb\->load( $line, ...)
.Ve
.Sp
loads the data lines given into the table, returns the table.
.Sp
Every argument to \f(CWload()\fR represents a data line to be added to the
table.  The line can be given as an array(ref) containing the data
items, or as a string, which is split on whitespace to retrieve the
data.  If an undefined argument is given, it is treated as an
empty line.
.IP \fBclear()\fR 4
.IX Item "clear()"
.Vb 1
\&    $tb\->clear;
.Ve
.Sp
deletes all data from the table and resets it to the state after
creation.  Returns the table.  The body height of a table is 0 after
\&\f(CWclear()\fR.
.SS "Table Output"
.IX Subsection "Table Output"
The three methods \f(CWtable()\fR, \f(CWtitle()\fR, and \f(CWbody()\fR are very similar.
They access different parts of the printable output lines of a table with
similar methods.  The details are described with the \f(CWtable()\fR method.
.IP \fBtable()\fR 4
.IX Item "table()"
The \f(CWtable()\fR method returns lines from the entire table, starting
with the first title line and ending with the last body line.
.Sp
In array context, the lines are returned separately, in scalar context
they are joined together in a single string.
.Sp
.Vb 3
\&    my @lines = $tb\->table;
\&    my $line  = $tb\->table( $line_number);
\&    my @lines = $tb\->table( $line_number, $n);
.Ve
.Sp
The first call returns all the lines in the table.  The second call
returns one line given by \f(CW$line_number\fR.  The third call returns \f(CW$n\fR
lines, starting with \f(CW$line_number\fR.  If \f(CW$line_number\fR is negative, it
counts from the end of the array.  Unlike the \f(CWselect()\fR method,
\&\f(CWtable()\fR (and its sister methods \f(CWtitle()\fR and \f(CWbody()\fR) is
protected against large negative line numbers, it truncates the
range described by \f(CW$line_number\fR and \f(CW$n\fR to the existing lines.  If
\&\f(CW$n\fR is 0 or negative, no lines are returned (an empty string in scalar
context).
.IP \fBstringify()\fR 4
.IX Item "stringify()"
Returns a string representation of the table. This method is called for
stringification by overload.
.Sp
.Vb 1
\&    my @table_strings = map { $_\->stringify() } @tables;
.Ve
.IP \fBtitle()\fR 4
.IX Item "title()"
Returns lines from the title area of a table, where the column titles
are rendered.  Parameters and response to context are as with \f(CWtable()\fR,
but no lines are returned from outside the title area.
.IP \fBbody()\fR 4
.IX Item "body()"
Returns lines from the body area of a table, that is the part where
the data content is rendered, so that \f(CW$tb\fR\->body( 0) is the first data
line.  Parameters and response to context are as with \f(CWtable()\fR.
.IP \fBrule()\fR 4
.IX Item "rule()"
.Vb 6
\&    $tb\->rule;
\&    $tb\->rule( $char);
\&    $tb\->rule( $char, $char1);
\&    $tb\->rule( sub { my ($index, $len) = @_; },
\&               sub { my ($index, $len) = @_; },
\&    );
.Ve
.Sp
Returns a rule for the table.
.Sp
A rule is a line of table width that can be used between table lines
to provide visual horizontal divisions, much like column separators
provide vertical visual divisions.  In its basic form (returned by the
first call) it looks like a table line with no data, hence a blank
line except for the non-blank parts of any column-separators.  If
one character is specified (the second call), it replaces the blanks
in the first form, but non-blank column separators are retained.  If
a second character is specified, it replaces the non-blank parts of
the separators.  So specifying the same character twice gives a solid
line of table width.  Another useful combo is \f(CW\*(C`$tb\->rule( \*(Aq\-\*(Aq, \*(Aq+\*(Aq)\*(C'\fR,
together with separators that contain a single nonblank "|", for a
popular representation of line crossings.
.Sp
\&\f(CWrule()\fR uses the column separators for the title section if there
is a difference.
.Sp
If callbacks are specified instead of the characters, then they receive the
index of the section of the rule they need to render and its desired length in
characters, and should return the string to put there. The indexes given
are 0 based (where 0 is either the left column separator or the leftmost
cell) and the strings will be trimmed or extended in the replacement.
.IP \fBbody_rule()\fR 4
.IX Item "body_rule()"
\&\f(CWbody_rule()\fR works like <\fBrule()\fR>, except the rule is generated using
the column separators for the table body.
.SS "Warning Control"
.IX Subsection "Warning Control"
.IP \fBwarnings()\fR 4
.IX Item "warnings()"
.Vb 4
\&    Text::Table\->warnings();
\&    Text::Table\->warnings( \*(Aqon\*(Aq);
\&    Text::Table\->warnings( \*(Aqoff\*(Aq):
\&    Text::Table\->warnings( \*(Aqfatal\*(Aq):
.Ve
.Sp
The \f(CWwarnings()\fR method is used to control the appearance of warning
messages while tables are manipulated.  When Text::Table starts, warnings
are disabled.  The default action of \f(CWwarnings()\fR is to turn warnings
on.  The other possible arguments are self-explanatory.  \f(CWwarnings()\fR
can also be called as an object method (\f(CW\*(C`$tb\->warnings( ...)\*(C'\fR).
.SH VERSION
.IX Header "VERSION"
This document pertains to Text::Table version 1.127
.SH BUGS
.IX Header "BUGS"
.IP o 4
.IX Item "o"
\&\fIauto\fR alignment doesn't support alternative characters for the decimal
point.  This is actually a bug in the underlying Text::Aligner by the
same author.
.SH AUTHOR
.IX Header "AUTHOR"
.SS MAINTAINER
.IX Subsection "MAINTAINER"
Shlomi Fish, <http://www.shlomifish.org/> \- CPAN ID: "SHLOMIF".
.SS "ORIGINAL AUTHOR"
.IX Subsection "ORIGINAL AUTHOR"
.Vb 4
\&    Anno Siegel
\&    CPAN ID: ANNO
\&    siegel@zrz.tu\-berlin.de
\&    http://www.tu\-berlin.de/~siegel
.Ve
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2002 Anno Siegel. All rights reserved.
This program is free software; you can redistribute
it and/or modify it under the terms of the ISC license.
.PP
(This program had been licensed under the same terms as Perl itself up to
version 1.118 released on 2011, and was relicensed by permission of its
originator).
.PP
The full text of the license can be found in the
LICENSE file included with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::Table::Tiny supports a simple model for generating
text tables, with some flexibility on the look of the table.
.PP
Text::Table::Manifold provides a much richer interface for
defining tables. The SEE ALSO section of its documentation
lists a lot more table modules on CPAN.
.PP
Text::Aligner can be used to align text on a line-by-line basis.
.SH EXAMPLES
.IX Header "EXAMPLES"
.SS "center align and Unicode output"
.IX Subsection "center align and Unicode output"
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&    use utf8;
\&
\&    use Text::Table ();
\&
\&    binmode STDOUT, \*(Aq:encoding(utf8)\*(Aq;
\&
\&    my @cols = qw/First Last/;
\&    push @cols,
\&        +{
\&        title => "Country",
\&        align => "center",
\&        };
\&    my $sep = \e\*(Aq│\*(Aq;
\&
\&    my $major_sep = \e\*(Aq║\*(Aq;
\&    my $tb        = Text::Table\->new( $sep, " Number ", $major_sep,
\&        ( map { +( ( ref($_) ? $_ : " $_ " ), $sep ) } @cols ) );
\&
\&    my $num_cols = @cols;
\&
\&    $tb\->load( [ 1, "Mark",    "Twain",   "USA", ] );
\&    $tb\->load( [ 2, "Charles", "Dickens", "Great Britain", ] );
\&    $tb\->load( [ 3, "Jules",   "Verne",   "France", ] );
\&
\&    my $make_rule = sub {
\&        my ($args) = @_;
\&
\&        my $left      = $args\->{left};
\&        my $right     = $args\->{right};
\&        my $main_left = $args\->{main_left};
\&        my $middle    = $args\->{middle};
\&
\&        return $tb\->rule(
\&            sub {
\&                my ( $index, $len ) = @_;
\&
\&                return ( \*(Aq─\*(Aq x $len );
\&            },
\&            sub {
\&                my ( $index, $len ) = @_;
\&
\&                my $char = (
\&                      ( $index == 0 )             ? $left
\&                    : ( $index == 1 )             ? $main_left
\&                    : ( $index == $num_cols + 1 ) ? $right
\&                    :                               $middle
\&                );
\&
\&                return $char x $len;
\&            },
\&        );
\&    };
\&
\&    my $start_rule = $make_rule\->(
\&        {
\&            left      => \*(Aq┌\*(Aq,
\&            main_left => \*(Aq╥\*(Aq,
\&            right     => \*(Aq┐\*(Aq,
\&            middle    => \*(Aq┬\*(Aq,
\&        }
\&    );
\&
\&    my $mid_rule = $make_rule\->(
\&        {
\&            left      => \*(Aq├\*(Aq,
\&            main_left => \*(Aq╫\*(Aq,
\&            right     => \*(Aq┤\*(Aq,
\&            middle    => \*(Aq┼\*(Aq,
\&        }
\&    );
\&
\&    my $end_rule = $make_rule\->(
\&        {
\&            left      => \*(Aq└\*(Aq,
\&            main_left => \*(Aq╨\*(Aq,
\&            right     => \*(Aq┘\*(Aq,
\&            middle    => \*(Aq┴\*(Aq,
\&        }
\&    );
\&
\&    print $start_rule, $tb\->title,
\&        ( map { $mid_rule, $_, } $tb\->body() ), $end_rule;
.Ve
.PP
This emits the following output:
.PP
.Vb 9
\&    ┌────────╥───────┬───────┬─────────────┐
\&    │ Number ║ First │ Last  │Country      │
\&    ├────────╫───────┼───────┼─────────────┤
\&    │1       ║Mark   │Twain  │     USA     │
\&    ├────────╫───────┼───────┼─────────────┤
\&    │2       ║Charles│Dickens│Great Britain│
\&    ├────────╫───────┼───────┼─────────────┤
\&    │3       ║Jules  │Verne  │   France    │
\&    └────────╨───────┴───────┴─────────────┘
.Ve
.SH SUPPORT
.IX Header "SUPPORT"
.SS Websites
.IX Subsection "Websites"
The following websites have more information about this module, and may be of help to you. As always,
in addition to those websites please use your favorite search engine to discover more resources.
.IP \(bu 4
MetaCPAN
.Sp
A modern, open-source CPAN search engine, useful to view POD in HTML format.
.Sp
<https://metacpan.org/release/Text\-Table>
.IP \(bu 4
RT: CPAN's Bug Tracker
.Sp
The RT ( Request Tracker ) website is the default bug/issue tracking system for CPAN.
.Sp
<https://rt.cpan.org/Public/Dist/Display.html?Name=Text\-Table>
.IP \(bu 4
CPANTS
.Sp
The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.
.Sp
<http://cpants.cpanauthors.org/dist/Text\-Table>
.IP \(bu 4
CPAN Testers
.Sp
The CPAN Testers is a network of smoke testers who run automated tests on uploaded CPAN distributions.
.Sp
<http://www.cpantesters.org/distro/T/Text\-Table>
.IP \(bu 4
CPAN Testers Matrix
.Sp
The CPAN Testers Matrix is a website that provides a visual overview of the test results for a distribution on various Perls/platforms.
.Sp
<http://matrix.cpantesters.org/?dist=Text\-Table>
.IP \(bu 4
CPAN Testers Dependencies
.Sp
The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies for a distribution.
.Sp
<http://deps.cpantesters.org/?module=Text::Table>
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests by email to \f(CW\*(C`bug\-text\-table at rt.cpan.org\*(C'\fR, or through
the web interface at <https://rt.cpan.org/Public/Bug/Report.html?Queue=Text\-Table>. You will be automatically notified of any
progress on the request by the system.
.SS "Source Code"
.IX Subsection "Source Code"
The code is open to the world, and available for you to hack on. Please feel free to browse it and play
with it, or whatever. If you want to contribute patches, please send me a diff or prod me to pull
from your repository :)
.PP
<https://github.com/shlomif/Text\-Table>
.PP
.Vb 1
\&  git clone git://github.com/shlomif/Text\-Table.git
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
Shlomi Fish <shlomif@cpan.org>
.SH BUGS
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
<https://github.com/shlomif/Text\-Table/issues>
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2002 by Anno Siegel and others.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The ISC License
.Ve
.SH SUPPORT
.IX Header "SUPPORT"
.SS Websites
.IX Subsection "Websites"
The following websites have more information about this module, and may be of help to you. As always,
in addition to those websites please use your favorite search engine to discover more resources.
.IP \(bu 4
MetaCPAN
.Sp
A modern, open-source CPAN search engine, useful to view POD in HTML format.
.Sp
<https://metacpan.org/release/Text\-Table>
.IP \(bu 4
RT: CPAN's Bug Tracker
.Sp
The RT ( Request Tracker ) website is the default bug/issue tracking system for CPAN.
.Sp
<https://rt.cpan.org/Public/Dist/Display.html?Name=Text\-Table>
.IP \(bu 4
CPANTS
.Sp
The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.
.Sp
<http://cpants.cpanauthors.org/dist/Text\-Table>
.IP \(bu 4
CPAN Testers
.Sp
The CPAN Testers is a network of smoke testers who run automated tests on uploaded CPAN distributions.
.Sp
<http://www.cpantesters.org/distro/T/Text\-Table>
.IP \(bu 4
CPAN Testers Matrix
.Sp
The CPAN Testers Matrix is a website that provides a visual overview of the test results for a distribution on various Perls/platforms.
.Sp
<http://matrix.cpantesters.org/?dist=Text\-Table>
.IP \(bu 4
CPAN Testers Dependencies
.Sp
The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies for a distribution.
.Sp
<http://deps.cpantesters.org/?module=Text::Table>
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests by email to \f(CW\*(C`bug\-text\-table at rt.cpan.org\*(C'\fR, or through
the web interface at <https://rt.cpan.org/Public/Bug/Report.html?Queue=Text\-Table>. You will be automatically notified of any
progress on the request by the system.
.SS "Source Code"
.IX Subsection "Source Code"
The code is open to the world, and available for you to hack on. Please feel free to browse it and play
with it, or whatever. If you want to contribute patches, please send me a diff or prod me to pull
from your repository :)
.PP
<https://github.com/shlomif/Text\-Table>
.PP
.Vb 1
\&  git clone git://github.com/shlomif/Text\-Table.git
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
Shlomi Fish <shlomif@cpan.org>
.SH BUGS
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
<https://github.com/shlomif/Text\-Table/issues>
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2002 by Anno Siegel and others.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The ISC License
.Ve
